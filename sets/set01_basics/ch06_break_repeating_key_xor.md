# 破解循环密钥异或

> 现在你上道了。
> 
> 这道题从概念上来说不难，但是实际写出来的代码很容易出错。本卷题集中的其他题目都是为了让你跟上进度，而这道题真正在**验证你的能力**。你如果能做出来这道题，去做第六卷很可能都没问题。

[给出一个文件](../../golang/6.txt)，这个文件被循环密钥加密后又用base64编码了一下。

请解出明文。

以下是手把手教程：

1. 设`KEYSIZE`为密钥长度，无妨设密钥长度介于2到（大概）40之间。
2. 写函数计算两个字符串的编辑距离/汉明距离。*汉明距离*指的是两个字符串中不同字节的数目。给定下面两个字符串：
    ```
    "this is a test"
    ```
    和
    ```
    "wokka wokka!!!"
    ```
    他们的汉明距离是**37**。用这个例子验证你写的函数没问题之后再往下走。
3. 对每个`KEYSIZE`，从密文中，取`KEYSIZE`个字节大小的子串两个，计算出两个子串的编辑距离。通过`编辑距离/KEYSIZE`得到规范化过的编辑距离。
4. 有着最小规范编辑距离的`KEYSIZE`很可能就是密钥的长度。你可以尝试按前2-3名最小编辑距离的`KEYSIZE`处理，或者取`4*KEYSIZE`大小的块，然后取平均值。
5. 到这一步，你大概已经破解出了`KEYSIZE`。接下来把密文按照`KEYSIZE`的长度划分为多块。
6. 现在对这些密文块进行转置操作：从每一块中取出第一个字节作为新的第一块，所有块的第二个字节作为新的第二块，以此类推。
7. 按照前面做过的，破解单字节循环异或的方法，解出每个块。
8. 对一个块做解密，结果统计上最好看的字节，就是这个块的密钥；把所有字节串起来，你就得到了原始的循环密钥。

你现在写的代码在后面可能出奇地好用；使用统计学方法破解循环密钥异或加密（“Vigenere算法”）显然只是个象牙塔里的小练习，是密码学的入门小品。然而，很多人只是“知道怎么破解”，并没有*真正做到破解*，同理，对于破解其他更重量级的密码也是如此。

> 本文真的没有出错。
> 
> 这道题比别的题收到了更多的工单疑问。我们保证，本文没有明显的错误。具体来说，`wokka wokka!!!`的编辑距离真的是37。